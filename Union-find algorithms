/* UNION FIND ALGORITHMS

  algorighm                     worst-case time

  quick-find                         M N
  quick-union                        M N
  weighed QU                      N + M log N
  QU + path compression           N + M log N
  weighed QU + path compression   N + M lg* N

  where
  M is union-find operations on a set of N objects
  lg* N is number of times you have to take log N to get 1 (iterate log function); in practice, never more than 5

*/

////////////////////////////////////////////////////////////////////////////////////////////////
// Quick find algorithm for dynamic connectivity problem (described in detail
// at http://algs4.cs.princeton.edu/15uf/ )

var QuickFind = (function(){
    var id = [];

    // create a list of ids for every node in the network; its id
    // will be equal to its position in the array to start with;
    // This is O(n) operation since you are looping through the every node in N

    var createIdArray = function(N){
        for (var i=0; i<N; i++){
            id[i] = i;
        }
    }

    // check if two nodes are connected; if they are, their ids will be the same

    var connected = function(p, q){
        return id[p] === id[q];
    }

    // introduce a new connection between two nodes; Have to loop through
    // all items in N checking their ids, hence this is also O(n) operation, which
    // makes the overall algorithm O(n^2)

    var union = function(p, q){
        var pid = id[p];
        var qid = id[q];
        for (var i = 0; i < id.length; i++){
            if (id[i] === pid){
                id[i] = qid;
            }
        }
    }

    return {
        createIdArray: createIdArray,
        connected: connected,
        union: union
    };

})();


//////////////////////////////////////////////////////////////////////////////////////////////
// Quick union algorithm for dynamic connectivity problem (described in detail
// at http://algs4.cs.princeton.edu/15uf/ )

var QuickUnion = (function(){
    var id = [];

    // create a list of ids for every node in the network; its id
    // will be equal to its position in the array to start with;
    // This is O(n) operation since you are looping through the every node in N

    var createIdArray = function(N){
        for (var i=0; i<N; i++){
            id[i] = i;
        }
    }

    // find the root of the node; in the worst case scenario you will need to
    // traverse all the items in the array to find the root (if all the components are
    // connected and you are querying one at the bottom of the tree). In that case, this operation
    // is O(n).

    var root = function(i){
        while (i !== id[i]){
            i = id[i];
        }
        return i;
    }

    // check if two nodes are connected; if they are, they will have the same root

    var connected = function (p, q){
        return root(p) === root(q);
    }

    // introduce a new connection between two nodes; get the roots of two nodes;
    // assign the root of one node to become the root of another;

    var union = function(p, q){
       var i = root(p);
       var j = root(q);
       id[i] = j;
    }

    return {
            createIdArray: createIdArray,
            connected: connected,
            union: union
    };

})();



////////////////////////////////////////////////////////////////////////////////////////////////
// Weighed quick union algorithm with path compression for dynamic connectivity problem (described in detail
// at http://algs4.cs.princeton.edu/15uf/ )

var WQUPC = (function(){
    var id = [];
    // array to monitor the size of trees
    var sz = [];

    // create a list of ids for every node in the network; its id
    // will be equal to its position in the array to start with;
    // This is O(n) operation since you are looping through the every node in N

    var createIdArray = function(N){
        for (var i=0; i<N; i++){
            id[i] = i;
            sz[i] = 1;
        }
    }

    // find the root of the node;

    var root = function(i){
        while (i !== id[i]){
            // introduce a path compression change - when you find the root of the tree,
            // set it to be the parent of queried node; this flattens the tree.
            id[i]=id[id[i]];
            i = id[i];
        }
        return i;
    }

    // check if two nodes are connected; if they are, they will have the same root

    var connected = function(p, q){
        return root(p) === root(q);
    }

    // introduce a new connection between two nodes; get the roots of two nodes;
    // assign the root of one node to become the root of another;

    var union = function (p, q){
       var i = root(p);
       var j = root(q);
       // changes to introduce the weighing of tree sizes
       if (i === j){
        return;
       }
       if (sz[i] < sz[j]){
        id[i] = j;
        sz[j] += sz[i];
       } else {
        id[j] = i;
        sz[i] += sz[j];
       }
    }

     return {
                createIdArray: createIdArray,
                connected: connected,
                union: union
     };

})();

/////////////////////////////////////////////////////////////////////////////////////////////////////////